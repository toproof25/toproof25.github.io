---
title: 옵시디언 문서를 Github Page로 변환 및 이동
description: null
date: 2025-09-19
categories:
- GitHub Page
- 환경설정
tags:
- Jekyll
- GitHub
- GutHubPage
img: /assets/img/2025-09-19-옵시디언-문서를-Github-Page로-변환-및-이동/
---
## 옵시디언 문서를 Github Page로 변환 및 이동
> 옵시디언을 이용하여 학습한 내용들을 기록하였는데 Github Page를 구현하면서 옵시디언 문서를 post하기 위해 변환하는 작업을 해야 한다.
> 같은 마크다운을 사용하지만 옵시디언의 경우 이미지나 문서 링크는 `[[]]`으로 사용하기도 하였고, 프론트 메타 데이터도 Jekyll chirpy 테마에 적용되도록 조금 씩 변경해야 한다. 
> 이런 변환을 효율적으로 수행하기 위해 Pyhon을 이용하여 변환 프로그램을 제작하고자 한다.

### 원하는 기능
변환에 앞서 기본적인 기능을 생각해보았다

- 옵시디언 문서를 간편하게 Jekyll에서 빌드할 수 있는 md파일로 변환할 수 있어야 한다
- 필요없는 프론트 메다 데이터는 제거할 수 있어야 한다
- md파일에 작성된 모든 옵시디언 문법 링크를 완벽하게 Jekyll로 변환되어야 한다
- post에 이미지도 필요하기에 사용된 모든 이미지를 webp로 변환하여 `assets/img/문서제목`으로 저장되어야 한다
- 다른 md파일 링크에 대해서도 블로그에서 이동할 수 있도록 변환되어야 한다

## md파일 제목 및 프론트 메타 변환

### 파일 제목 변환
Jekyll로 Github Page에서 Post문서를 제작할 때는 문서 제목 앞에 `YYYY-MM-DD`를 포함해야 한다.

만약 `test markdown.md` 문서가 있다면, 변환이 수행되면서 `2025-09-19-test-markdown.md`제목으로 변환되고, 문서가 작성되어야 post를 했을 때 정상적으로 보이게 된다.

### 프론트 메타 변환
우선 기존에 옵시디언을 사용하면서 `title`, `date`, `tags`는 기본적으로 사용하였기에 거의 모든 문서에 적용되어 있었다. 그렇기에 파일 제목 변환도 Python에서 YAML을 읽어온 후 `date + title`을 통해서 간단하게 파일 제목을 간단하게 변환할 수 있었다.

추가적으로 `description`, `categories`를 추가하였는데 이 과정은 Python을 사용한 게 아닌 VS Code에서 정규식을 이용하여 일괄적으로 모든 문서에 추가할 수 있었다.

또한 필요없는 `URL`, `aliases`, `uid`, `cssclasses`같은 값은 변환 작업 시 제거되도록 구현하였다
```text
title: 옵시디언 문서를 Github Page로 변환 및 이동
description: 
date: 2025-09-19
categories:
- GitHub Page
- 환경설정
tags:
- Jekyll
- GitHub
- GutHubPage

URL: 
aliases: []
uid: 20250919203423
cssclasses:
  - width-95
```

## 이미지 링크 변환 (마크다운, webp)

### 마크다운 변환
옵시디언에서는 간단하게 `[[]]`로 문서와 이미지 등을 링크할 수 있으나 Jekyll는 기존 마크다운 문법을 사용하기에 빌드가 되지 않는다
그렇기에 옵시디언에서 사용한 문법을 모두 빌드가 가능한 마크다운 형탬로 변경할 수 있어야 한다

- 이미지 링크 `![이미지 제목]({{page.img}}이미지 제목.webp)` -> `![이미지 제목](이미지 경로)`로 변환

초기에 테스트를 해보면서 Jekyll에서 이미지나 다른 문서를 링크하려면, 경로를 정확하게 설정할 수 있어야 했다.

예를 들어 다음과 같이 변환이 되어야 한다.

- **옵시디언 이미지 링크 : `![Docker 다운중]({{page.img}}Docker 다운중.webp)`**
- **Jekyll 이미지 링크 : `![Docker 다운중]({{page.img}}Docker 다운중.webp)`**

이미지는 `assets/img/문서제목/`에 저장하는데 이를 매번 `assets/img/문서제목/Docker 다운중.webp`와 같이 작성하기에는 불편함이 있었다.

각 문서마다 프론트 메타에 `img`를 두고, `/assets/img/ + 작성일자 + 문서제목`을 사용하여 해당 문서에서는 항상 `{page.img} + 이미지 제목.webp`로 연결할 수 있도록 한다.

여기서는 `img: /assets/img/2025-09-13-Docker를-설치하여-환경-설정/`이와 같이 작성되어 있다.
즉 `![Docker 다운중]({{page.img}}Docker 다운중.webp)`은 결국
`![Docker 다운중](/assets/img/2025-09-13-Docker를-설치하여-환경-설정/Docker 다운중.webp)`이렇게 작성되는 것과 같다

### 이미지 복사

#### 옵시디언에서 이미지 찾기
옵시디언에서 이미지를 링크(`![[]]`)하면 자동으로 이미지 경로가 내부적으로 적용되어 문서에 보이게 된다.

문제는 post를 하기 위해 마크다운만 변환해봤자 이미지가 해당 경로에 존재하지 않으면 이미지를 post문서에 보여줄 수 없다. 나는 변환하는 작업에서 마크다운을 포함하여 이미지까지 자동으로 post에서 사용할 수 있도록 해당 경로에 복사되는 기능을 추가하고자 한다.

하지만 옵시디언에서 `![Docker 다운중]({{page.img}}Docker 다운중.webp)`이렇게 작성해도 결국 경로를 알 수 없다.
이미지의 이름과 확장자만 알 수 있는데 나는 옵시디언에서 모든 이미지 문서는 `Source/`폴더에 모아두기에 `Source/`를 기준으로 이미지 제목을 비교하여 실제 사용한 이미지를 찾을 수 있었다.

1. 옵시디언 md -> Jekyll md 변환 수행
2. 마크다운 문법을 변환한다
3. 이미지 링크인 경우 `이미지 제목.png`를 `Source/`폴더에서 찾는다
4. `Source/`에서 찾은 이미지를 원하는 경로에 복사한다

#### 경로에 맞는 폴더 자동 생성
이미지만 복사한다고 post에 보이지는 않는다. 경로를 정확하게 설정해야 하는데 위에서 말했듯 이미지는 `/assets/img/`에 저장하며, 이미지 마크다운 문법을 변환할 때 `/assets/img/2025-09-13-Docker를-설치하여-환경-설정/`해당 경로를 기준으로 이미지 소스를 찾게 된다.

즉 이미지를 post문서에 보이게 하고 싶다면, `/assets/img/`에 md파일 제목 폴더를 생성한 후 이 폴더에 사용하고자 하는 모든 이미지를 복사해야 한다.

보다 편리하게 변환하기 위해 자동으로 md파일 제목으로 폴더를 생성하고, 해당 폴더에 이미지를 복사하도록 구현하였다.

1. 옵시디언 md -> Jekyll md 변환 수행
2. `/assets/img/` 경로에 `YYYY-MM-DD-문서제목` 폴더를 생성한다
3. 옵시디언 md문서를 Jekyll 마크다운 문법을 변환한다
4. 이미지 링크인 경우 `이미지 제목.png`를 `Source/`폴더에서 찾는다
5. `Source/`에서 찾은 이미지를 2번에서 생성한 폴더 경로에 복사한다

이렇게 이미지 링크를 변환하면, 마크다운 문법이 변환되는 동시에 사용한 이미지 또한 설정한 경로에 복사되어 바로 이미지를 띄울 수 있게 되었다

### PNG -> Webp
여기까지만 해도 이미지는 보이게 되나 이미지 용량이 걱정되기에 추가적으로 이미지 확장자를 변환하는 작업을 추가했다

대부분 이미지가 png로 되어 있었고, .jpg든 .png든 모든 이미지는 변환할 때 .webp로 변환된 후에 폴더로 복사되도록 하였다


## 문서 링크 변환
옵시디언에서 사용한 타 문서 링크의 경우 다음 4가지 경우가 있었다
- 기본 링크 : `[[test 문서입니다]]`
- 별칭 링크 : `[[test 문서입니다|별명]]`
- 특정 헤더 링크 : `[[test 문서입니다#첫번째 주제]]`
- 특정 헤더와 별칭 링크: `[[test 문서입니다#두번째 주제|test 두번째 주제]]`

이에 대해 대응하는 Jekyll 마크다운 변환의 결과는 다음과 같다
- 기본 링크 : `[test 문서입니다]({% raw %}{% post_url 2025-01-01-test-문서입니다 %}{% endraw %})`
- 별칭 링크 : `[별명]({% raw %}{% post_url 2025-01-01-test-문서입니다 %}{% endraw %})`
- 특정 헤더 링크 : `[test 문서입니다]({% raw %}{% post_url 2025-01-01-test-문서입니다 %}{% endraw %}#첫번째-주제)`
- 특정 헤더와 별칭 링크: `[test 두번째 주제]({% raw %}{% post_url 2025-01-01-test-문서입니다 %}{% endraw %}#두번째-주제)`

혹시 문서 링크도 정확한 경로를 작성해야 하나 싶었지만, 이 경우에는 `post_url`을 작성하면 알아서 빌드했을 때 링크가 될 수 있어서 다행이었다

### 문서 경로 찾기
이미지와 같은 이유로 옵시디언에서 작성한 md파일 만으로는 실제 링크한 md파일이 어디있는 지 알 수 없다

이게 왜 문제가 되냐고 하면 post문서에 링크를 설정하기 위해서는 문서 제목만이 아닌 작성한 날짜로 알아야 하기 때문이다
`[[test 문서입니다]]` -> `[test 문서입니다]({% raw %}{% post_url 2025-01-01-test-문서입니다 %}{% endraw %})`

작성한 날짜는 실제 문서에 접근하거나 해당 문서에 있는 프론트 메타 값 `date`를 알아야 하는데 어찌됐든 문서를 옵시디언 폴더 내에서 찾아야 한다.

그렇기에 옵시디언 root 폴더를 경로로 설정한 후 변환을 수행할 때 `[[문서제목]]`링크에 대해 **문서제목**을 통해 실제 옵시디언 내 `문서제목.md`파일을 찾고, 제목을 변환하게 된다

1. 옵시디언 md -> Jekyll md 변환 수행
2. 마크다운 문법을 변환한다
3. 문서 링크인 경우 `문서제목`을 옵시디언 모든 폴더에서 찾는다
4. 링크 문서를 찾았다면, 해당 링크의 프론트 메타값 date와 title을 이용하여 `YYYY-MM-DD-문서제목`으로 변환하게 된다

해당 문서의 프론트 메타값을 사용하는 이유로는 결국 내가 변환하고자 하는 모든 문서는 해당 문서의 프론트 메타 값을 사용하기에 Jekyll에서 링크되는 문서의 제목도 해당 문서의 프론트 메타 값을 사용해야 추후 불편함이 없을 것이라고 생각했다


## 프로그램 구현
프로그램의 경우 Python을 사용하였으며, 최대한 빠르게 구현하기 위해 AI를 많이 사용하여 구현하였다.

기본적인 요구사항과 알고리즘을 설명하여 Python 프로그램을 개발하였으며, tk GUI를 적용하여 보다 편리하게 사용할 수 있도록 하였다

### 경로 설정

다음은 실행한 프로그램에서 경로 설정 모습이며, 각 경로는 다음과 같다

- Source 폴더 : 변환하고자 하는 md파일이 있는 경로 (경로 내 모든 폴더 내 md파일을 포함)
- Post 폴더 : 변환된 md파일이 저장되는 경로 (md파일만 저장된다)
- 이미지 폴더 : 변환/복사된 이미지가 저장되는 경로 (폴더 생성 후 이미지가 저장된다)
- 이미지 소스 : 이미지 링크 변환 시 복사할 이미지가 있는 폴더
- Obsidian 루트 : 문서 링크 변환 시 문서의 위치를 찾는 옵시디언 root 폴더

![다음은 실행한 프로그램에서 경로 설정 모습이며, 각 경로는 다음과 같다]({{page.img}}다음은 실행한 프로그램에서 경로 설정 모습이며, 각 경로는 다음과 같다.webp)

우선 변환되는 md파일과 복사/변환되는 이미지 파일들이 저장될 곳을 설정할 수 있어야 한다

md문서의 경우 `_post`에서 먼저 카테고리 별로 폴더를 구성한 다음 최종적으로 저장할 경로를 설정한다. 해당 경로에 바로 md파일이 변환되어 저장될 것이다
`post_target` : `.../_posts/Github Page 구성`

![md문서의 경우 _post에서 먼저 카테고리 별로 폴더를 구성한 다음 최종적으로 저장할 경로를 설정한다]({{page.img}}md문서의 경우 _post에서 먼저 카테고리 별로 폴더를 구성한 다음 최종적으로 저장할 경로를 설정한다.webp)

이미지 문서는 `img/` 폴더 내부에 각각 문서에 해당하는 폴더 제목으로 모두 저장된다.
변환 작업 시 작성한 알고리즘대로 각각 문서 제목에 해당하는 폴더가 생성되고 이미지가 채워질 것이다
`img_target` : `.../assets/img/`

![이미지 문서는 img 폴더 내부에 각각 문서에 해당하는 폴더 제목으로 모두 저장된다]({{page.img}}이미지 문서는 img 폴더 내부에 각각 문서에 해당하는 폴더 제목으로 모두 저장된다.webp)

### 변환 파일 확인 및 제거

Source 폴더 경로를 설정하면 다음과 같이 변환할 md파일들이 리스트로 나타난다
여기서는 간단하게 어떤 md파일이 포함되는지 확인 가능하며, 더블클릭시 변환하지 않을 파일을 제거할 수 있다

![Source 폴더 경로를 설정하면 다음과 같이 변환할 md파일들이 리스트로 나타난다]({{page.img}}Source 폴더 경로를 설정하면 다음과 같이 변환할 md파일들이 리스트로 나타난다.webp)

### 변환 실행

변환하기 버튼을 누르면 변환이 진행되며, 그 과정이 로그로 나타난다
로그에는 현재 진행중인 md파일의 변환 과정이 나타나며, 최종적으로 결과가 나타난다
특히 문법에 오류가 있거나 변환이 안되는 링크 등에 대해서는 오류를 출력하여 직접 수정할 수 있도록 하였다

![변환하기 버튼을 누르면 변환이 진행되며, 그 과정이 로그로 나타난다]({{page.img}}변환하기 버튼을 누르면 변환이 진행되며, 그 과정이 로그로 나타난다.webp)

### 최종 결과물

최종 결과물은 다음과 같이 프로그램이 구성되었으며 (숨길거는 없지만 경로는 일단 가리기...) 정상적으로 작동한다

![최종 결과물은 다음과 같이 프로그램이 구성되었으며]({{page.img}}최종 결과물은 다음과 같이 프로그램이 구성되었으며.webp)

하나를 예로 들자면 이런 식으로 옵시디언에서 정리한 **CMake**에 대한 주제가 있다

![하나를 예로 들자면 이런 식으로]({{page.img}}하나를 예로 들자면 이런 식으로.webp)

이후 프로그램에서 각 경로를 설정한다
- 변환할 문서가 있는 경로
- 문서 저장할 경로
- 이미지 저장 경로
- 이미지 소스 경로
- 옵시디언 루트 경로

![이후 프로그램에서 각 경로를 설정한다]({{page.img}}이후 프로그램에서 각 경로를 설정한다.webp)

문서를 저장할 경로는 다음과 같이 `_post`에 폴더를 구성하였다

![문서를 저장할 경로는 다음과 같이 `_post`에 폴더를 구성하였다]({{page.img}}문서를 저장할 경로는 다음과 같이 `_post`에 폴더를 구성하였다.webp)

경로를 설정하면 다음과 같이 변환할 md파일 목록이 나타난다
여기서는 제외할 문서가 없으니 그대로 진행

![Source 폴더 경로를 설정하면 다음과 같이 변환할 md파일들이 리스트로 나타난다]({{page.img}}Source 폴더 경로를 설정하면 다음과 같이 변환할 md파일들이 리스트로 나타난다.webp)

변환하기 버튼을 눌러 변환을 수행

![변환하기 버튼을 누르면 변환이 진행되며, 그 과정이 로그로 나타난다]({{page.img}}변환하기 버튼을 누르면 변환이 진행되며, 그 과정이 로그로 나타난다.webp)

변환 전에는 해당 경로에 아무 파일이 없었으나

![변환 전에는 해당 경로에 아무 파일이 없었으나]({{page.img}}변환 전에는 해당 경로에 아무 파일이 없었으나.webp)

변환이 완료되면, 자동으로 옵시디언 문서와 이미지 폴더가 생성된다
이미지 폴더가 하나인 이유는 4개의 문서 중 이미지를 사용한 md파일이 하나이기 때문

![변환이 완료되면, 자동으로 옵시디언 문서와 이미지 폴더가 생성된다]({{page.img}}변환이 완료되면, 자동으로 옵시디언 문서와 이미지 폴더가 생성된다.webp)

이런 식으로 앞으로 남은 모든 옵시디언 문서와 작성할 문서를 변환할 프로그램을 구현하였다.

물론 아직 사용하다보니 부족한 기능이 있기데 계속 사용해가면서 기능을 추가할 예정이다


## 구현하면서 느낀점
사실 AI가 없었다면 직접 코드를 공부하고 제작하는 수고가 있었겠지만, AI발전으로 모르는 부분이라도 어느정도 아이디어와 계획이 있으면 이렇게 프로그램을 구현하여 실제로 사용할 수 있다는 점이 AI의 장점이라고 생각한다.

앞으로는 더 강력해지는 AI를 어떻게 다루고 사용할 수 있을 지 이것도 공부가 필요하고 생각해봐야 겠다는 느낌이 들었다



---
## 링크 및 참고자료

##### 링크 문서
- 

##### 참고자료(출처)
- 



