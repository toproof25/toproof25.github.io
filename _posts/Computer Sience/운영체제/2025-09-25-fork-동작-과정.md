---
title: fork 동작 과정
description: null
date: 2025-09-25
categories:
- Computer Science
- 운영체제
tags:
- 운영체제
- 컴퓨터공학
img: /assets/img/2025-09-25-fork-동작-과정/
---
## fork 동작 과정
*온라인 코딩 <https://www.onlinegdb.com/>*
```cpp
#include <stdio.h>
#include <unistd.h>
int main()
{
    fork();
    printf("Operating System\n");
    return 0;
}
```
코드에서 `fork()`를 만나게 되면 부모 프로세스 PCB를 그대로 복사하여 커널에 등록된다
1. fork시 자식 프로세스는 고유한 PID를 부여받는다
2. 부모 프로세서에서 fork는 자식의 PID를 리턴한다
3. 자식 프로세서에서 fork는 0을 반환한다

이후 `printf`에서 보면 부모 프로세스에서 먼저 `Operating System` 문구가 호출이 된다. 특이한 점은 문맥교환이 일어나고 부모 PCB를 복사하면서 프로그램 카운터도 복사된 자식 프로세스도 `fork()`시점에 부모의 프로그램 카운터인 `printf`명령 실행을 가지고 있어 자식 프로세스도 `Operating System`를 출력하게 된다
```bash
Operating System
Operating System
```

출력이 두개가 나오는 이유는 부모의 PCB를 복사하면서 fd도 같이 복사하게 된다. 간단하게 생각해서 부모는 현재 test.cpp에서 A라는 콘솔창을 이용하고 `fork()`와 `printf()`를 수행한다. 여기서 자식도 마찬가지로 부모를 복사했기에 그대로 A콘솔창을 사용하게 된다.

그렇다고 부모의 소스 코드가 실행되는 것은 아니다. 위 예시에서는 같은 문구를 출력하기에 같인 결과가 나타난다고 오해할 수 있다. 아래의 경우는 생성된 순간 자식 프로세스의 PID값을 `ret_pid`에 저장하고 출력하게 된다. 이때 부모 프로세스의 경우 자식 프로세스 PID가 출력되지만, 자식의 경우 자식 프로세스가 없기에 0이 나타난다. 
```cpp
#include <stdio.h>
#include <unistd.h>
int main()
{
    pid_t ret_pid;
    ret_pid = fork();
    printf("%d Operating System\n", ret_pid);
    return 0;
}
```

*실행 결과*
```bash
3858 Operating System
0 Operating System
```

다음은 더 자세하게 구분하기 위해 조건문으로 부모와 자식 프로세스를 구분하여 출력하는 예시
```cpp
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    pid_t ret_pid;    
    int x = 1;

    printf("메인 프로세스 (PID: %d)\n", getpid());
    ret_pid = fork();

    if (ret_pid > 0) {
        // 부모 프로세스
        printf("나는 부모 프로세스이다. 내 자식의 PID는 %d이다.\n", ret_pid);
        printf("parent: x=%d\n", --x);
        wait(NULL);
        printf("내 자식이 종료되었다.\n");
    } else if (ret_pid == 0) {
        // 자식 프로세스
        printf("나는 자식 프로세스이다. 내 부모의 PID는 %d이다.\n", getppid());
        printf("fork()의 반환값은 %d이다.\n", ret_pid);
        printf("child: x=%d\n", ++x);
    }
    
    return 0;
}
```

```bash
메인 프로세스 (PID: 8240)
나는 부모 프로세스이다. 내 자식의 PID는 8244이다.
parent: x=0
나는 자식 프로세스이다. 내 부모의 PID는 8240이다.
fork()의 반환값은 0이다.
child: x=2
내 자식이 종료되었다.
```

이 경우에는 x변수가 부모와 자식 프로세스와 다르게 나타나는데 이는 부모의 메모리 공간을 그대로 복사하나 독립적으로 가지기 때문이다. 이때 **[Copy On Write]({% post_url 2025-09-25-Copy-On-Write %})**가 적용된다. 

또한 CPID와 조건문을 통해 부모 프로세스와 자식 프로세스를 구분하여 출력하고, `wait`을 이용하여 자식 프로세스의 종료를 기다린 후 마지막으로 부모 프로세스의 `printf`가 출력된다 




---
## 링크 및 참고자료

##### 링크 문서
- [Process]({% post_url 2025-09-18-Process %})
- [Copy On Write]({% post_url 2025-09-25-Copy-On-Write %})
- [file descriptor]({% post_url 2025-09-18-file-descriptor %})

##### 참고자료(출처)
- 



