---
title: WGS84앵커과 고도 적용
description: null
date: 2025-05-21
categories:
- Projects
- Unity
- AR-Navgation-Unity
tags:
- 지식
- 캡스톤VR
- Unity
- ARCore
img: /assets/img/2025-05-21-WGS84앵커과-고도-적용/
---
# WGS84 앵커
- ## Tracking 상태 확인
	- Tracking 상태는 Google API를 사용하기 위해서 필수적으로 조건에 만족해야 하며, 디바이스의 카메라나 위치 등 정보가 원활하게 동작하는 상태를 의미한다
	-  먼저 Tracking 상태를 체크한 후 길찾기를 수행하도록 코드를 작성
		  ```cpp
		// Tracking 상태 확인
		valueLog.text += $"[{DateTime.Now:HH:mm:ss}] [정보] Tracking 시도\n";
		var state = earthManager.EarthTrackingState;
		valueLog.text += $"[{DateTime.Now:HH:mm:ss}] [정보] 현재 EarthTrackingState = {state}\n";
		if (state != TrackingState.Tracking)
		{
			valueLog.text += $"[{DateTime.Now:HH:mm:ss}] [Tracking Error] 예상: Tracking, 실제: {state}\n";
			yield break;
		}
		valueLog.text += $"[{DateTime.Now:HH:mm:ss}] [정보] Tracking 성공\n";
		
		// Tranking을 위한 프레임 넘기기
		yield return null;
		  ```
	- Tracking상태가 정상적일 경우 다음으로 Tmap API를 이용하여 길찾기를 수행한다
- ## Tmap API 보행자 길찾기
	- 요청하고자 하는 출발지, 목적지의 경위도, 이름, 기타 옵션을 설정한다
	  `string jsonBody = JsonUtility.ToJson(bodyObj);` 을 이용하겨 C# 객체를 JSON 문자열로 변환
	  ```cpp
	// 요청 바디 생성
	var bodyObj = new PedestrianRequest
	{
		startX = lon.ToString(),                        // 출발지 경위도
		startY = lat.ToString(),
		endX = destinationLongitude.ToString(),         // 목적지 경위도
		endY = destinationLatitude.ToString(),
		startName = UnityWebRequest.EscapeURL("출발지"), // 각 이름 
		endName = UnityWebRequest.EscapeURL("도착지"),   
		reqCoordType = "WGS84GEO",                       // WGS84GEO (기본값)
		resCoordType = "WGS84GEO",                        
		searchOption = "0",                             // 추천 경로(기본값)
		sort = "index"                                  // 정렬 (기본값)
	};
	string jsonBody = JsonUtility.ToJson(bodyObj);
		```
	- 요청할 데이터를 작성한 후 Tmap API로 직접 요청하여 응답까지 대기
	  ```cpp
	// POST 요청
	string url = "https://apis.openapi.sk.com/tmap/routes/pedestrian?version=1";
	UnityWebRequest req = new UnityWebRequest(url, "POST");
	byte[] bytes = System.Text.Encoding.UTF8.GetBytes(jsonBody);
	req.uploadHandler = new UploadHandlerRaw(bytes);
	req.downloadHandler = new DownloadHandlerBuffer();
	req.SetRequestHeader("Content-Type", "application/json"); // 보내는 형식이 JSON임을 명시
	req.SetRequestHeader("Accept", "application/json");       // 받는 형식도 JSON임을 명시
	req.SetRequestHeader("appKey", appKey);                   // Tmap API Key를 설정
	yield return req.SendWebRequest();                        // 요청 후 응답까지 대기
	  ```
	- 응답받은 데이터가 정상임을 확인 - 비정상이면 바로 코루틴을 종료
	  ```cpp
	if (req.result != UnityWebRequest.Result.Success)
	{
		mapLog.text = "[오류] 경로 요청 실패";
		valueLog.text += $"[{DateTime.Now:HH:mm:ss}] [오류] {req.result}\n";
		yield break;
	}
	  ```
	- 직렬화 클래스로 응답받은 JSON을 매핑한다
	- JSON은 **키-값**으로 이루어져 있는데 이를 C#에서 객체로 똑같이 구조를 이루기 위해 클래스를 만들고 사용한다 
	  ```cpp
	// 직렬화 클래스로 JSON 매핑
	TmapRouteResponse route = JsonUtility.FromJson<TmapRouteResponse>(req.downloadHandler.text);
	if (route == null || route.features == null)
	{
		mapLog.text = "[오류] 응답 파싱 실패";
		valueLog.text += $"[{DateTime.Now:HH:mm:ss}] [오류] 응답 JSON 파싱 실패\n";
		yield break;
	}
	  ```
- ## WGS앵커 생성
	- 디바이스 회전값을 가져온다
	  ```cpp
	// 카메라 GeospatialPose(위경도 및 EunRotation) 가져오기
	GeospatialPose camPose = earthManager.CameraGeospatialPose;
	Quaternion eunRotation = camPose.EunRotation;
	  ```
	- 응답받은 JSON을 순회하면서 type이 **Point**인 경위도에만 앵커를 설치한다
	  ```cpp
		// WGS84 앵커 생성 (위도, 경도, 고도, EunRotation)
		var anchor = anchorManager.AddAnchor(
			latitude,
			longitude,
			ellipsoidalHeight,
			eunRotation
		);
		yield return new WaitForSeconds(0.3f);

		if (anchor == null)
		{
			valueLog.text += $"[{DateTime.Now:HH:mm:ss}] [앵커 생성 실패]\n";
			continue;
		}
		yield return new WaitForSeconds(0.5f);

		// 앵커에 프리팹을 자식으로 인스턴스화
		var marker = Instantiate(YourAnchorPrefab, anchor.transform);
		Vector3 worldPos = marker.transform.position;
		valueLog.text += $"[{DateTime.Now:HH:mm:ss}] [앵커 배치 성공] 월드좌표: {worldPos}\n";
	  ```
- ## 빌드 후 테스트
	- 테스트 결과 경로에 해당하는 위치에 앵커들이 큰 오차없이 나타나있는 것을 확인
	- 하지만 고도를 임의로 설정하여 앵커가 아래쪽으로 위치하는 것을 확인
	- 우선 WGS84 좌표를 바탕으로 Unity 공간에 위치하고, 실제 현실과 Unity 씬 위치가 어느정도 일치하는 것을 확인할 수 있었다.
	- 다음 과제는 고도를 어느정도 맞추는 작업
	  ![우선 WGS84 좌표를 바탕으로 Unity 공간에 위치하고, 실제 현실과 Unity 씬 위치가 어느정도 일치하는 것을 확인할 수 있었다.]({{page.img}}우선 WGS84 좌표를 바탕으로 Unity 공간에 위치하고, 실제 현실과 Unity 씬 위치가 어느정도 일치하는 것을 확인할 수 있었다..webp)


# 오류 발생 및 해결
- 이것저것 해봐도 WGS84 앵커가 동작하지 않았는데 이 문제의 원인은 다음과 같음
- ARCore Extensions는 Unity6 이전 버전에서 계속 업그레이드 되던 라이브러리
- 그렇기에 이전에 사용하면 AR Origin을 이용하는데 AR Foundation5 이후로는 XR Origin을 사용함
- 처음 설치했을 때 부터 이게 안맞는다는 것을 알고 있었으나 AR Origin이 사라진 것은 아니라 XR Origin을 그냥 AR Origin으로 바꾸고 사용함
- 찾아보니 ARCore Extensions애서 2025년 2월에 Unity6과 AR Foundation6 이상 버전을 지원하는 버전을 업데이트함
- 재설치 후 적용해보니 앵커가 동작하는 것을 확인

---
##### 링크 문서
- [[캡스톤VR - Unity6 GPS 경도, 위도 받아오기]]
- [[캡스톤VR - Tmap API 사용하기]]



##### 참고자료(출처)
- [Google AR Core API 공식 문서 - Tracking 상태 확인](https://developers.google.com/ar/develop/unity-arf/geospatial/obtain-device-pose?hl=ko)
- [Google AR Core API 공식 문서 - WGS84 앵커 생성하기](https://developers.google.com/ar/develop/unity-arf/geospatial/anchors?hl=ko#wgs84_anchors)
- [Tmap API 공식 문서 - 보행자 경로 요청 및 응답](https://openapi.sk.com/products/detail?linkMenuSeq=45#Body_Parameters)



